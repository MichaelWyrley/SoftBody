// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalculateParticles
#pragma kernel CalculateSprings
#pragma kernel ClearSpring
#pragma kernel Accumulator
#pragma kernel ProjectCollisions

static const float EPSILON = 1e-6f;
static const float3 GRAVITY = float3(0.0,-9.81,0.0);
static const float MAX_DIST = 0.5f;
static const float FLOAT_TO_INT = 100000.0f;
static const float INV_FLOAT_TO_INT = 1.0f / 100000.0f;

int solverIterations;
int gridSize;
// float springStiffness;
float compliance;
float damping;
float friction;
float global_damping;
float dt;

struct ParticleData 
{

    float3 position;
    float  pad0;
    float3 velocity;
    float  pad1;
    float3 force;
    float  pad2;
    float  mass;
    float  inv_mass;
    float  radius;
    float  collisionDamping;
};
struct SpringData
{
    uint p1, p2;
    float restLength;
    float pad;
};

struct GroundData 
{
    uint triangle_begin;
    uint triangle_count;
    float3 bounds_min;
    float3 bounds_max;
};
struct Triangles
{
	float3 posA;
	float3 posB;
	float3 posC;
};

RWStructuredBuffer<ParticleData> particles;
RWStructuredBuffer<float3> predicted_pos;
RWStructuredBuffer<float> spring_lambdas;
RWStructuredBuffer<int3> pos_delta_accumulator;
StructuredBuffer<SpringData> springs;
StructuredBuffer<GroundData> ground;
StructuredBuffer<Triangles> ground_mesh;

/*

Particles 

*/


void UpdateParticle(uint particle_id)
{

    ParticleData p = particles[particle_id];

    // Apply gravity as force
    float3 x_new = predicted_pos[particle_id];
    float3 x_old = p.position;

    // compute velocity from change
    p.velocity += (x_new - x_old) / dt;

    p.velocity *= global_damping;

    // Integrate motion
    p.velocity += (GRAVITY) * dt ;

    if (abs(p.velocity.x) < 0.01f && abs(p.velocity.y) < 0.01f && abs(p.velocity.z) < 0.01f){
        p.velocity = float3(0.0f,0.0f,0.0f);
    }
    
    // As we add the collisions and gravity to the velocity we don't need the last part of the equation + ∆t^{2}M^{−1}f^{ext}(x_n) (which represents outside forces)
    p.position = x_new;


    float3 p_tild = x_new + dt * p.velocity;
    predicted_pos[particle_id] = p_tild;
    particles[particle_id] = p;
}




[numthreads(64,1,1)]
void CalculateParticles (uint3 id : SV_DispatchThreadID)
{
    int particle_id = id.x;


    if (particle_id >= particles.Length){
        return;
    }
    UpdateParticle(particle_id);
}


/*

Collisions

*/


bool IntersectBox(float3 position, float3 bound_min, float3 bound_max, float radius)
{
    float3 r = float3(radius, radius, radius);
    float3 minE = bound_min - r;
    float3 maxE = bound_max + r;
    return all(position >= minE - EPSILON) && all(position <= maxE + EPSILON);
}

// Closest point on triangle (Ericson)
float3 ClosestPointOnTriangle(float3 p, float3 a, float3 b, float3 c)
{
    float3 ab = b - a;
    float3 ac = c - a;
    float3 ap = p - a;

    float d1 = dot(ab, ap);
    float d2 = dot(ac, ap);
    if (d1 <= 0.0 && d2 <= 0.0) return a; // bary (1,0,0)

    float3 bp = p - b;
    float d3 = dot(ab, bp);
    float d4 = dot(ac, bp);
    if (d3 >= 0.0 && d4 <= d3) return b; // bary (0,1,0)

    float vc = d1 * d4 - d3 * d2;
    if (vc <= 0.0 && d1 >= 0.0 && d3 <= 0.0)
    {
        float v = d1 / (d1 - d3);
        return a + v * ab;                 // bary (1-v, v, 0)
    }

    float3 cp = p - c;
    float d5 = dot(ab, cp);
    float d6 = dot(ac, cp);
    if (d6 >= 0.0 && d5 <= d6) return c;   // bary (0,0,1)

    float vb = d5 * d2 - d1 * d6;
    if (vb <= 0.0 && d2 >= 0.0 && d6 <= 0.0)
    {
        float w = d2 / (d2 - d6);
        return a + w * ac;                 // bary (1-w, 0, w)
    }

    float va = d3 * d6 - d5 * d4;
    if (va <= 0.0 && (d4 - d3) >= 0.0 && (d5 - d6) >= 0.0)
    {
        float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
        return b + w * (c - b);            // bary (0,1-w,w)
    }

    // Inside face region
    float denom = 1.0 / (va + vb + vc);
    float v2 = vb * denom;
    float w2 = vc * denom;
    return a + ab * v2 + ac * w2;
}


void ResolveCollisions(int particle_id)
{
    float3 pos = predicted_pos[particle_id];
    ParticleData p = particles[particle_id];

    // Per-collision clamp to avoid huge jumps
    const float maxCorrection = 0.25f; // meters per contact, tune as needed

    // Early out if no ground geometry
    if (ground.Length == 0 || ground_mesh.Length == 0)
    {
        // still write back (no change)
        predicted_pos[particle_id] = pos;
        return;
    }

    for (uint g = 0; g < ground.Length; g++)
    {
        GroundData obj = ground[g];

        if (!IntersectBox(pos, obj.bounds_min, obj.bounds_max, p.radius))
            continue;

        uint begin = obj.triangle_begin;
        uint end   = begin + obj.triangle_count;

        for (uint t = begin; t < end; t++)
        {
            Triangles tri = ground_mesh[t];

            // Skip degenerate triangles
            float3 e1 = tri.posB - tri.posA;
            float3 e2 = tri.posC - tri.posA;
            float3 triN = cross(e1, e2);
            float area2 = length(triN);
            if (area2 < EPSILON) continue;
            triN /= area2; // Normalize

            float3 closest = ClosestPointOnTriangle(pos, tri.posA, tri.posB, tri.posC);
            float3 diff = pos - closest;
            float dist = length(diff);

            // If within radius, we have penetration (or contact)
            if (dist < p.radius)
            {
                float3 contactN;
                if (dist > EPSILON)
                {
                    contactN = diff / dist;        // true contact normal
                }
                else
                {
                    // If we landed exactly on the triangle, fall back to face normal
                    contactN = triN;
                }

                // Penetration depth along contact normal
                float penetration = p.radius - dist;

                // Clamp correction to avoid big jumps
                float3 correction = contactN * min(penetration + EPSILON, maxCorrection);

                // Apply positional correction
                pos += correction;

                // Velocity response:
                // Split velocity into normal/tangent; damp normal, apply friction on tangent
                float vn = dot(p.velocity, contactN);
                float3 vN = vn * contactN;
                float3 vT = p.velocity - vN;

                // Only if moving into the surface
                if (vn < 0.0f)
                {
                    // Restitution-like damping on normal (use your per-particle collisionDamping if desired)
                    float restitution = clamp(1.0f - p.collisionDamping, 0.0f, 1.0f);
                    vN *= -restitution;

                    // Simple Coulomb-ish friction shrink on tangent
                    vT *= (1.0f - clamp(friction, 0.0f, 1.0f));
                }

                p.velocity = vN + vT;
            }
        }
    }

    predicted_pos[particle_id] = pos;
    particles[particle_id] = p;
}



[numthreads(64,1,1)]
void ProjectCollisions (uint3 id : SV_DispatchThreadID)
{
    int particle_id = id.x;


    if (particle_id >= particles.Length){
        return;
    }
    ResolveCollisions(particle_id);
}

/*

Springs 

*/

void UpdateSpring(uint spring_id ) {

    SpringData s = springs[spring_id];

    ParticleData p1 = particles[s.p1];
    ParticleData p2 = particles[s.p2];

    float3 pos_1 = predicted_pos[s.p1];
    float3 pos_2 = predicted_pos[s.p2];

    float3 delta = pos_2 - pos_1;
    float dist = length(delta);

    if (dist < EPSILON) dist = EPSILON;
    float3 n = normalize(delta / dist); 

    float C = dist - s.restLength;

    float lambda_old = spring_lambdas[spring_id];

    float alpha_tild = compliance / (dt*dt);


    float dlambda = (-C - alpha_tild * lambda_old) / (p1.inv_mass + p2.inv_mass + alpha_tild);


    float3 corr = dlambda * n;

    if (length(corr) > MAX_DIST) {
        corr = normalize(corr) * MAX_DIST;
    }

    
    float3 c1 = p1.inv_mass * corr;
    float3 c2 = -p2.inv_mass * corr;

    int3 c1i = int3(round(c1 * FLOAT_TO_INT));
    int3 c2i = int3(round(c2 * FLOAT_TO_INT));
    
    spring_lambdas[spring_id] += dlambda;

    InterlockedAdd(pos_delta_accumulator[s.p1].x, c1i.x);
    InterlockedAdd(pos_delta_accumulator[s.p1].y, c1i.y);
    InterlockedAdd(pos_delta_accumulator[s.p1].z, c1i.z);

    InterlockedAdd(pos_delta_accumulator[s.p2].x, c2i.x);
    InterlockedAdd(pos_delta_accumulator[s.p2].y, c2i.y);
    InterlockedAdd(pos_delta_accumulator[s.p2].z, c2i.z);

    
}



[numthreads(64,1,1)]
void CalculateSprings (uint3 id : SV_DispatchThreadID)
{
    int spring_id = id.x;


    if (spring_id >= springs.Length){
        return;
    }

    UpdateSpring(spring_id);
}

[numthreads(64,1,1)]
void ClearSpring (uint3 id : SV_DispatchThreadID)
{
    int spring_id = id.x;


    if (spring_id >= spring_lambdas.Length){
        return;
    }

    spring_lambdas[spring_id] = 0.0f;
}

[numthreads(64,1,1)]
void Accumulator (uint3 id : SV_DispatchThreadID)
{
    int particle_id = id.x;


    if (particle_id >= pos_delta_accumulator.Length){
        return;
    }

    int3 di = pos_delta_accumulator[particle_id];
    float3 df = float3(di) * INV_FLOAT_TO_INT;
    predicted_pos[particle_id] += df;
    pos_delta_accumulator[particle_id] = int3(0,0,0); // clear for next iteration
}